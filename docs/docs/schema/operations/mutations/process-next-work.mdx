---
pagination_next: null
pagination_prev: null
id: process-next-work
title: processNextWork
---




export const Bullet = () => <><span style={{ fontWeight: 'normal', fontSize: '.5em', color: 'var(--ifm-color-secondary-darkest)' }}>&nbsp;●&nbsp;</span></>

export const SpecifiedBy = (props) => <>Specification<a className="link" style={{ fontSize:'1.5em', paddingLeft:'4px' }} target="_blank" href={props.url} title={'Specified by ' + props.url}>⎘</a></>

export const Badge = (props) => <><span className={props.class}>{props.text}</span></>

import { useState } from 'react';

export const Details = ({ dataOpen, dataClose, children, startOpen = false }) => {
  const [open, setOpen] = useState(startOpen);
  return (
    <details {...(open ? { open: true } : {})} className="details" style={{ border:'none', boxShadow:'none', background:'var(--ifm-background-color)' }}>
      <summary
        onClick={(e) => {
          e.preventDefault();
          setOpen((open) => !open);
        }}
        style={{ listStyle:'none' }}
      >
      {open ? dataOpen : dataClose}
      </summary>
      {open && children}
    </details>
  );
};








This will pick up non-external work, execute, await result and finish
it up on the target system. This function allows you to do work queue "ticks"
from outside instead of waiting for default Cron and Event Listener to trigger
and can be helpful in serverless environments.


```graphql
processNextWork(
  worker: String
): Work
```




### Arguments

#### [<code style={{ fontWeight: 'normal' }}>processNextWork.<b>worker</b></code>](#)<Bullet />[`String`](/schema/types/scalars/string.mdx) <Badge class="badge badge--secondary" text="scalar"/> 



### Type

#### [`Work`](/schema/types/objects/work.mdx) <Badge class="badge badge--secondary" text="object"/> 







